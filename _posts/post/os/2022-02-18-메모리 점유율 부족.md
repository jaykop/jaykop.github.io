---
title: "메모리 및 CPU 부족 현상"
classes: wide
categories: 
  - post
  - OS
sidebar:
  nav: "main"
author_profile: true
---
   
## 메모리(RAM) 점유율의 상승하면?
* 메인 드라이브에 가상메모리 영역을 설정
  * 해당 영역을 메모리처럼 사용
  * 낮은 단계에 가상 메모리가 잡힐수록 엑세스 속도가 느려짐
  * 이 같은 이유로 RAM 메모리가 많을수록 좋다는 것

## 가상 메모리
![image](/assets/images/Virtual_memory.png)
* 주메모리 RAM이 여유가 없어 오염되는 경우를 방지하기 위해 사용
* 하나의 프로세스 중 일부는 RAM에 물리 주소를, 일부는 디스크에 가상 주소를 할당
  * 프로그램이 작동하면서 가상 주소와 물리 주소의 내용을 스위칭해가면서 프로그램을 실행
* 메모리 관리 장치 MMU를 통해 가상 메모리 주소를 실제 메모리주소로 변환

## 페이징
* 프로세스를 물리적 단위로 동일한 크기로 분할하여 메모리에 할당
  * 돼지고기를 같은 크기로 나누어 보관
* **페이지** - 고정 사이즈의 가상 메모리 내 프로세스 조각
* **프레임** - 고정 사이즈의 주 메모리 내 프로세스 조각

### 페이징 테이블
* 메인 메모리의 시작 주소값과 페이지 번호가 매핑되어 있는 테이블
* 이를 통해 가상 메모리가 물리 메모리 주소값을 추적할 수 있다

### 페이징의 장단점
* 장점
   - 연속성으로부터 자유로움
   - 외부 단편화가 발생하지 않음
* 단점
   - 내부 단편화 발생

## 세그멘테이션
* 프로세스를 논리적 단위로 나누어 서로 크기가 다른름
  * 돼지고기를 부위별로 나누어 보관

### 세그멘테이션 테이블
* 분할 방식을 제외하고서는 페이징과 똑같이 테이블에 매핑되어 있다

### 세그멘테이션 장단점
* 장점
  - 내부 단편화 문제 해소
  - 프로세스를 기능별로 분류했기 때문에, 보호 및 공유가 가능
* 단점
  - 외부 단편화 문제 발생

## 단편화 Fragmentation
* **메모리 공간에 사용되지 않는 작은 공간이 발생하는 현상**

### 내부 단편화 Internal Fragmentation
* 프로세스가 메모리를 할당할 때 **필요한 양보다 더 큰 단위로 할당**
  * 할당은 10k 만큼 받았지만 실제 필요량은 7K
  * 3k를 낭비
* 페이징 기법을 사용할 때 발생

### 외부 단편화 External Fragmentation
* **여유 공간의 총합은 충분하지만 실제로는 분할**되어 있어 가용할 수 없는 경우
* 세그멘테이션 기법을 사용할 때 발생

## CPU도 작업량이 증가하면?
* CPU는 멀티프로그래밍, 멀티태스킹으로 동작
  * 번갈아가며 여러 프로세스를 처리
* 작업량이 많아져 부하가 걸리면 하나의 프로세르를 처리하는 데 시간이 오래걸릴 수 있음
  * 정지상태로 걸리면 다음 프로세스로 넘어가기는 할 것

## 출처
* <https://quasarzone.com/bbs/qf_cmr/views/100445>
* <https://namu.wiki/w/%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC?from=%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC>
* <https://namsieon.com/253>
* <https://junghyun100.github.io/%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%8B%A8%ED%8E%B8%ED%99%94/>