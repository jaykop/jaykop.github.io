---
title: "Sorting"
classes: wide
categories: 
  - post
  - etc
sidebar:
  nav: "main"
author_profile: true
---

## bubble sort

```c++
void bubble_sort(vector<int>& v)
{
	int size = static_cast<int>(v.size());

	for (int i = 0; i < size - 1; ++i)
	{
		bool swapped = false;

		// 매번 탐색한 범위에서 가장 큰 element를 맨 뒤로 밀어냄
		// => 비교할 범위를 줄임
		for (int j = 0; j < size - i - 1; ++j)
		{
			if (v[j] > v[j + 1])
			{
				swapped = true;
				swap(v[j], v[j + 1]);
			}
		}
		
		// done sorting
		if (!swapped)
			break;
	}
}
```

## selection sort

```c++
void selection_sort(vector<int>& v)
{
	// 탐색한 범위 중 가장 작은 element를 맨 앞으로 보냄
	int size = static_cast<int>(v.size());

	for (int i = 0; i < size - 1; ++i)
	{
		bool swapped = false;

		int min = i;
		for (int j = i; j < size; ++j)
		{
			if (v[min] > v[j])
				min = j;
		}

		if (min != i)
			swap(v[min], v[i]);
	}
}
```

## insertion sort

```c++
void insertion_sort(vector<int>& v)
{
	// 가상의 sorted와 unsorted로 구간을 나누어 정렬
	int size = static_cast<int>(v.size());

	for (int i = 1; i < size ; ++i)
	{
		// 적정 위치에 갈 때까지 체크/swap
		for (int j = i ; j > 0; --j)
		{
			if (v[j] < v[j - 1])
				swap(v[j], v[j - 1]);
		}
	}
}
```

## merge sort

```c++
// divide 후 conquer하는 과정에 sorting
void merge_sort(vector<int>& v, int l, int r)
{
	if (l < r)
	{
		int mid = (l + r) / 2;

		// divide
		merge_sort(v, l, mid);
		merge_sort(v, mid + 1, r);

		// conquer
		int i = 0, j = 0, k = l,
			n1 = mid - l, n2 = r - (mid + 1);

		// 두 갈래로 나누어 복사
		vector<int> left(v.begin() + l, v.begin() + mid + 1),
			right(v.begin() + mid + 1, v.begin() + r + 1);

		// 나눠 복사한 배열에서 순차적으로 비교하며 새 배열로 값 복사
		while (i <= n1 && j <= n2)
		{
			if (left[i] < right[j])
				v[k++] = left[i++];

			else
				v[k++] = right[j++];
		}

		// 위에서 한쪽 배열이 먼저 끝날 경우,
		// 나머지 배열을 복사
		while (i <= n1)
			v[k++] = left[i++];

		while (j <= n2)
			v[k++] = right[j++];
	}
}
```

## quick sort

```c++
// divide 하는 과정에서 swap을 통해 sorting
void quick_sort(vector<int>& v, int l, int r)
{
	int i = l, j = r;
	int mid = v[(l + r) / 2];

	while (i <= j)
	{
		while (v[i] < mid)
			++i;

		while (mid < v[j])
			--j;

		if (i <= j)
		{
			swap(v[i], v[j]);
			++i, --j;
		}
	}

	if (l < j) quick_sort(v, l, j);
	if (i < r) quick_sort(v, i, r);
}
```

## Locality (지역성)
* CPU가 짧은 시간 범위 내에 일정 구간의 메모리 영역을 반복적으로 엑세스하는 경향
	* 메모리 정보를 균일하게 엑세스 하는 것이 아님
	* 짧은 시간 내에 특정 부분을 집중적으로 참조
* 함수 설계 및 사용처를 보고 특정 메모리를 캐시에 올려 재사용할 수 있음
	* 현재 프로세스의 실행 패턴을 보고 가까운 미래에 프로세스의 코드와 데이터를 합리적으로 사용하도록 예측
	* 자주 사용되는 페이지를 물리 메모리와 캐시 메모리에 둠
* 지역성의 정도가 떨어지면 캐시에 접근하지 않고 메인 메모리로 접근

## quick sort vs. merge sort

**merge sort**
![post_thumbnail](/assets/images/1_5CQ_RqNaiHnZAl9PYpTMYQ.gif)

**quick sort**
![post_thumbnail](/assets/images/1_AN0o2gSP3ZjYagmk0cbE5A.gif)

* merge sort는 정렬할 전 구간에 걸쳐 엑세스
* quick sort는 divide한 구간을 차례로 반복적으로 엑세스
* **참조의 지역성**
	* 대부분의 프로그램들은 모두 단시간에 반복적으로 접근하는 데이터가 존재
	* 이 과정을 효율적으로 수행하기 위해 캐시 사용
* quick sort이 merge sort보다 더 참조의 지역성 성질을 띰
	* 캐시의 도움을 더 받음

# 출처
* <https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html>
* <https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html>
* <https://medium.com/pocs/locality%EC%9D%98-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-quick-sort%EA%B0%80-merge-sort%EB%B3%B4%EB%8B%A4-%EB%B9%A0%EB%A5%B8-%EC%9D%B4%EC%9C%A0-824798181693>